[{"name":"server.R","content":"library(shiny)\nlibrary(magrittr)\nlibrary(DT)\n\n# implement dean attali's local storage suggestion:\noutputDir <- \"scores\"\ndir.create(outputDir, showWarnings = FALSE)\n\nsaveData <- function(data) {\n  # Create a unique file name\n  fileName <- sprintf(\"%s_%s.csv\", as.integer(Sys.time()), digest::digest(data))\n  # Write the file to the local system\n  write.csv(\n    x = data,\n    file = file.path(outputDir, fileName), \n    row.names = FALSE, quote = TRUE\n  )\n}\n\nloadData <- function() {\n  # Note:  function returns NULL if no scores yet\n  # Read all the files into a list\n  files <- list.files(outputDir, full.names = TRUE)\n  data <- lapply(files, read.csv, na.strings = c(\"\",\"NA\"),\n                 stringsAsFactors = FALSE) \n  # Concatenate all data together into one data.frame\n  data <- do.call(rbind, data)\n  data\n}\n\n\n# bounds for intercept\nlowa <- -5\nhigha <- 5\n# bounds for slope\nlowb <- -2\nhighb <- 2\n# error sd\nsigma <- 3\nn <- 10 # number of points in in cloud\nx <- 1:10 # x-values\n\n# read in players records\nscoreCount <- length(list.files(outputDir))\nif ( scoreCount > 0 ) {\n  leaders <- loadData()\n  } else leaders <- data.frame()\n\n# Define server logic for FindRegLine\nfunction(input, output, session) {\n  \n  # users should start in different places\n  set.seed(as.numeric(Sys.time()))\n  \n  #initiate status values\n  rv <- reactiveValues(\n    beginning = TRUE,\n    playing = FALSE,\n    reporting = FALSE,\n    leaders = leaders\n  )\n  \n  #set up:\n  player_rank <- NULL\n  ta <- round(runif(1, min = lowa, max = higha), 2)\n  posneg <- rbinom(1, 1, 0.5)\n  tbmin <- ifelse(posneg == 1, highb/2, lowb)\n  tbmax <- ifelse(posneg == 1, highb, lowb/2)\n  tb <- round(runif(1, min = tbmin, max = tbmax), 2)\n  y <- ta+tb*x+rnorm(n,mean=0,sd=sigma)\n  #SS for the regression line:\n  mod <- lm(y~x)\n  ess <- sum((resid(mod))^2)\n  #determine nice limits for plot (and a slider):\n  reg.slope <- coef(mod)[2]\n  reg.int <- coef(mod)[1]\n  #Find range of y-intercepts of lines through\n  #points on scatterplot having slope = reg.slope\n  int.min <- min(y-reg.slope*x)\n  int.max <- max(y-reg.slope*x)\n  int.band <- (int.max-int.min)/2\n  #Expand this range, and make sure it includes 0:\n  int.mid <- (int.max+int.min)/2\n  lowa.slider <- floor(min(c(int.mid-1.2*int.band,-1,min(y)-1)))\n  higha.slider <- ceiling(max(c(int.mid+1.2*int.band,1,max(y)+1)))\n  #plot limits reflect this range, too:\n  ymin <- lowa.slider\n  ymax <- higha.slider\n  y.mean <- mean(y)\n  your.y <- rep(y.mean,n)\n  #SS for the line initially placed (a= mean(y),b=0):\n  total.ss <- sum((y-mean(y))^2)\n  your.ss <- total.ss\n  turns <- 0\n  close <- 100\n  score <- close + turns\n\n  # initiate a slider info:\n  rvSlider <- reactiveValues(\n    lowa.slider = lowa.slider,\n    higha.slider = higha.slider,\n    y.mean = y.mean\n  )\n  \n  #initiate bslider info\n  rvbSlider <- reactiveValues(\n    value = 0\n  )\n  \n  rvGraph <- reactiveValues(\n    ymin = ymin,\n    ymax = ymax\n  )\n\n  #make the a and b sliders\n  output$aslider <- renderUI({\n        sliderInput(\"a\",min=rvSlider$lowa.slider,max=rvSlider$higha.slider,\n                label=\"y-Intercept\",step=0.01,value=rvSlider$y.mean)\n        })\n  \n  output$bslider <- renderUI({\n        input$reset\n        sliderInput(\"b\",min=2*lowb,max=2*highb,label=\"Slope\",\n                    step=0.01,value=0)\n          })\n  \n  observeEvent(input$updateBoard,\n               {\n                  temp <- loadData()\n                  if (! is.null(temp)) {\n                    rv$leaders <- temp\n                    } else rv$leaders <- data.frame()\n               }\n               )\n  \n  observeEvent(input$submit,\n               {\n                 rv$beginning <- FALSE\n                 rv$playing <- TRUE\n                 turns <<- turns + 1\n                 your.y <<- input$a+input$b*x\n                 your.ss <<- sum((y-your.y)^2)\n                 close <<- 100*(your.ss-ess)/(total.ss-ess)\n                 score <<- turns+close\n               })\n  \n  observeEvent(input$enditall,\n               {\n                 rv$reporting <- TRUE\n                 rv$playing <- FALSE\n                 if (input$player != \"\") {\n                   # make record for the game just ended\n                   name <- input$player\n                   lastScore <- score\n                   time <- Sys.time()\n                   # update the leader board in case others are playing.\n                   # first, get the latest data:\n                   leaders <- loadData()\n                   # compute rank of player:\n                   if ( is.null(leaders) ) rank <- 1\n                   if ( ! is.null(leaders) ) {\n                     # sort it:\n                     leaders <- leaders[order(leaders$score),]\n                     leScore <- max(which(lastScore >= leaders$score))\n                     # the above will return -Inf if our player has best score\n                     if (!is.infinite(leScore)) {\n                      rank <- leScore + 1\n                      } else {\n                        rank <- 1\n                      }\n                     }\n                   # store rank for reporting:\n                   player_rank <<- rank\n                   # add this game to the board\n                   game <- data.frame(name = name, score = lastScore, \n                                      time = time)\n                   saveData(game)\n                   # update board so user will see his/her name right away:\n                   rv$leaders <- loadData()\n                 }\n               })\n  \n  observeEvent(input$reset,\n              {\n                rv$beginning <- TRUE\n                rv$reporting <- FALSE\n                rv$playing <- FALSE\n                #set up again:\n                ta <<- round(runif(1, min = lowa, max = higha), 2)\n                tb <<- round(runif(1, min = lowb, max = highb), 2)\n                y <<- ta+tb*x+rnorm(n,mean=0,sd=sigma)\n                #SS for the regression line:\n                mod <<- lm(y~x)\n                ess <<- sum((resid(mod))^2)\n                #determine nice limits for plot (and a slider):\n                reg.slope <<- coef(mod)[2]\n                reg.int <<- coef(mod)[1]\n                #Find range of y-intercepts of lines through\n                #points on scatterplot having slope = reg.slope\n                int.min <<- min(y-reg.slope*x)\n                int.max <<- max(y-reg.slope*x)\n                int.band <<- (int.max-int.min)/2\n                #Expand this range, and make sure it includes 0:\n                int.mid <<- (int.max+int.min)/2\n                rvSlider$lowa.slider <- floor(min(c(int.mid-1.2*int.band,-1,min(y)-1)))\n                rvSlider$higha.slider <- ceiling(max(c(int.mid+1.2*int.band,1,max(y)+1)))\n                #plot limits reflect this range, too:\n                rvGraph$ymin <- rvSlider$lowa.slider\n                rvGraph$ymax <- rvSlider$higha.slider\n                y.mean <<- mean(y)\n                rvSlider$y.mean <- y.mean # so a slider sets correctly\n                your.y <<- rep(y.mean,n)\n                #SS for the line initially placed (a= mean(y),b=0):\n                total.ss <<- sum((y-mean(y))^2)\n                your.ss <<- total.ss\n                turns <<- 0\n                close <<- 100\n                score <<- close + turns\n              })\n  \n  output$beginning <- reactive({\n    rv$beginning\n  })\n  \n  output$playing <- reactive({\n    rv$playing\n  })\n  \n  output$reporting <- reactive({\n    rv$reporting\n  })\n  \n  outputOptions(output,\"beginning\", suspendWhenHidden = FALSE)\n  outputOptions(output,\"playing\", suspendWhenHidden = FALSE)\n  outputOptions(output,\"reporting\", suspendWhenHidden = FALSE)\n  \n  \n output$gamecloud <- renderPlot({\n   input$submit #just in case user decides not to change line\n   plot(x,y,pch=16,col=\"blue\",ylim=c(rvGraph$ymin,rvGraph$ymax),\n        xlim=c(0,n))\n   points(0,0,cex=0.8,pch=16,col=\"green\")\n   abline(input$a,input$b)\n   abline(0,0,lty=2,col=\"green\")\n   lines(x=c(0,0),y=c(rvGraph$ymin,rvGraph$ymax),lty=2,col=\"green\")\n   current.y <- input$a + input$b * x\n   for(i in 1:n)  {\n     lines(x=c(x[i],x[i]),y=c(current.y[i],y[i]))\n   }\n })\n \n output$finalcloud <- renderPlot({\n   input$enditall\n   ymin <- rvGraph$ymin\n   ymax <- rvGraph$ymax\n   plot(x,y,pch=16,col=\"blue\",ylim=c(ymin,ymax),\n        xlim=c(0,n))\n   points(0,0,cex=0.8,pch=16,col=\"green\")\n   isolate(abline(input$a,input$b))\n   abline(0,0,lty=2,col=\"green\")\n   lines(x=c(0,0),y=c(ymin,ymax),lty=2,col=\"green\")\n   coefs <- coef(mod)\n   abline(coefs,col=\"red\",lwd=3)\n })\n \n output$score <- renderTable({\n   input$submit\n   input$reset\n   tab <- rbind(your.ss,ess,close,turns,round(score,3))\n   colnames(tab) <- \"Report\"\n   rownames(tab) <- c(\"Your ESS\",\n              \"Reg Line's ESS\",\n              \"Closeness Measure\",\n              \"Turns So Far\",\"Score So Far\")\n   tab\n }, rownames = TRUE)\n \n output$rank <- reactive({\n   input$enditall\n   paste0(\"<h3>Your rank for this game is: \", player_rank,\"<\/h3>\")\n })\n\n# before DT: \n#  output$leaders <- renderDataTable({\n#    input$enditall\n#    input$updateBoard\n#    leaders <<- read.csv(file = \"leaders.csv\", \n#             header = TRUE, stringsAsFactors = FALSE)\n#    leaders[order(leaders$score),]\n#  })\n#  \n# outputOptions(output, \"leaders\", suspendWhenHidden = FALSE)\n \n# try with DT\n \n  observeEvent(input$updateBoard, {\n    if ( ! rv$beginning ) {\n      temp <- loadData()\n      if ( ! is.null(temp) ) {\n        rv$leaders <- temp[order(temp$score), ]\n        }\n      }\n  })\n  \n  output$leaders <- DT::renderDataTable({\n    leaders <- rv$leaders\n    if ( nrow(leaders ) > 0 ) {\n      leaders <- leaders[order(leaders$score), ]\n      leaders$rank <- 1:nrow(leaders)\n      datatable(leaders, rownames = FALSE, \n                caption = \"Here is the Leader Board:\",\n                filter = \"bottom\") %>%\n        formatStyle(\n          'name',\n          backgroundColor = styleEqual(input$player, 'lightblue'))\n      }\n  })\n \n output$revelation <- renderTable({\n   if (input$enditall > 0) {\n     coefs <- round(coef(mod),2)\n     tab <- rbind(c(input$a,input$b),coefs)\n     rownames(tab) <- c(\"Your Line\",\"Regression Line\")\n     colnames(tab) <- c(\"y-Intercept\",\"Slope\")\n     tab\n     }\n })\n \n output$downloadData <- downloadHandler(\n   filename = function() {\n     \"leaderboard.csv\"\n   },\n   content = function(file) {\n     sep <- \",\"\n     # Write to a file specified by the 'file' argument\n     write.table(leaders, file, sep = sep,\n                 row.names = FALSE)\n   }\n )\n  \n}\n\n","type":"text"},{"name":"ui.R","content":"library(shiny)\nlibrary(shinythemes)\n\n# Define UI for FindRegLine application\nnavbarPage(\n  title = \"Can You Find the Regression Line?\",\n  theme = shinytheme(\"cerulean\"),\n  tabPanel(\n    title = \"The Game\",\n    sidebarPanel(\n      conditionalPanel(\n        condition = \"input.submit == 0 || output.beginning == true\",\n        textInput(\"player\",\"Enter your name\"),\n        helpText(\"How good are you at finding where the regression line lies?\",\n             \"Adjust the sliders below to change the y-intercept and the\",\n             \"slope of the solid line.\")\n        ),\n      conditionalPanel(\n        condition = \"input.submit == 0 || output.beginning == true || output.playing == true\",\n        uiOutput(\"aslider\"),\n        uiOutput(\"bslider\"),\n        br(),\n        helpText(\"When you are satisfied with the line, press the button below.\"),\n        actionButton(\"submit\",\"Submit New Guess\"),\n        br(),\n        helpText(\"Each press of the button counts as one turn.  Your score is the sum\",\n             \"of the number of turns you have taken so far and a 'closeness' measurement.\",\n             \"The closeness measurement is always 100 at the start of the game, and can \",\n             \"get as low as zero if your line matches the regression line exactly.\",\n              \"Therefore, lower scores are better!\")\n        ),\n      conditionalPanel(\n        condition = \"output.playing == true\",\n        actionButton(\"enditall\",label=\"I quit:  show the regression line!\")\n      ),\n      conditionalPanel(\n        condition = \"output.reporting == true\",\n        actionButton(\"reset\", \"Play Again\")\n      )\n    ),\n  mainPanel(\n      conditionalPanel(\n        condition = \"input.player != '' && output.reporting == true\",\n        htmlOutput(\"rank\")\n    ),\n      conditionalPanel(\n        condition=\"input.submit == 0 || (output.beginning == true || output.playing == true)\",\n        plotOutput(\"gamecloud\", width = \"500px\", height = \"500px\"),\n        HTML(\"<h5>(Note: x and y axes for the above plot are in yellow.)<\/h5>\"),\n        br()\n        ),\n      conditionalPanel(\n        condition=\"output.reporting == true\",\n        plotOutput(\"finalcloud\", width = \"500px\", height = \"500px\")\n        ),\n      fluidRow(\n        column(width = 6,\n               tableOutput(\"score\")),\n        column(width = 3,\n               conditionalPanel(\n                 condition=\"output.reporting == true\",\n                 tableOutput(\"revelation\")\n                 )\n        )\n      )\n    )\n  ),\n  tabPanel(\n    title = \"Leader Board\",\n    fluidRow(\n      column(width = 3,\n             actionButton(\"updateBoard\", \"Update (as others play)\")),\n      column(width = 3,\n             downloadButton('downloadData', 'Download'))\n    ),\n    HTML(\"<p> <\/p>\"),\n    DT::dataTableOutput(\"leaders\")\n  ),\n  tabPanel(\n    title = \"About\",\n    includeCSS(\"www/styles.css\"),\n    withMathJax(includeHTML(\"infoFiles/about.html\"))\n  )\n)\n","type":"text"},{"name":"DESCRIPTION","content":"Title: Find the Regession Line\nAuthor: Homer S. White\nAuthorUrl: http://statistics.rainandrhino.org\nLicense: GPL-3\nDisplayMode: Normal\nTags: regression\nType: Shiny","type":"text"},{"name":"infoFiles/about.Rmd","content":"---\ntitle: \"About this App\"\nauthor: \"Homer White\"\ndate: \"June 24, 2015\"\noutput:\n  html_fragment:\n    fig_caption: true\n---\n\n<div id = \"aboutfile\">\n<h1 class=\"title\">About the App<\/h1>\n<h4 class=\"author\"><em>Homer White<\/em><\/h4>\n\n\n## Determining the Score\n\n### The y-bar Line.\n\nGiven a set of $n$ points on a scatter plot:\n\n$$(x_1,y_1),(x_2,y_2),\\ldots,(x_n,y_n),$$\n\nthe $\\bar{y}$-line is defined to be the horizontal line whose y-intercept is:\n\n$$\\bar{y} = \\frac{\\sum_{i = 0}^{n} y_i}{n},$$\n\nthe mean of the $y$-coordinates of the points on the scatter plot.  Of all horizontal lines, it's the one that \"best fits\" the scatter plot, in the sense that you would use it to predict the $y$-value of an observation if you were not allowed to take its $x$-value into account.\n\nWhen you begin a game, the $\\bar{y}$-line is drawn for you.\n\n### Error Sum of Squares\n\nFor any line $l$ with equation $y = a + bx$, we define the *error sum of squares* (ESS for short) of the line as follows:\n\n$$ESS_{l} = \\sum_{i = 0}^{n} (y_i - (a + b x_i))^2.$$\n\nWhen you play the app, the ESS for the line you have at any given moment is the sum of the squares of the vertical lines (drawn on the plot) between the given data points and your line.\n\nThe regression line has the interesting property of being the line that makes the ESS as small as possible.   If your line has an ESS equal to that of the regression line, then it *is* the regression line!\n\nWhen you play the game, your \"closeness measure\" is determined by the following formula:\n\n$$\\text{closeness} = \\frac{ESS_{\\text{your current line}} - ESS_{\\text{the regression line}}}{ESS_{\\bar{y}\\text{-line}} - ESS_{\\text{the regression line}}} \\times 100.$$\n\nThus, the closeness measure computes how close your current line comes to the regression line with how close the $\\bar{y}$-line is to the regression line.  This comparison is multiplied by 100 so that you can think of it as a percentage. When the game begins your line *is* the $\\bar{y}$-line, so the closeness measure is 100%.\n\nYour score at any moment is:\n\n$$\\text{Score} = \\text{number of turns so far} + \\text{current closeness measure}.$$\n\n## Suggestions\n\nIt's often a good idea to work first with the slider that determines the slope.  Once you think you have the slope about right, use the intercept-slider to move the line up or down horizontally.  You won't get a new score report until you submit, but you can move the line around as much as you like before committing yourself to a submission.\n\nCan you think of a situation where it is in your best interests to stop?  (**Hint:  ** Each additional submission costs you an extra point.)\n\n<\/div>\n","type":"text"},{"name":"infoFiles/about.html","content":"\n\n\n<div id=\"aboutfile\">\n<h1 class=\"title\">\nAbout the App\n<\/h1>\n<h4 class=\"author\">\n<em>Homer White<\/em>\n<\/h4>\n<div id=\"determining-the-score\" class=\"section level2\">\n<h2>Determining the Score<\/h2>\n<div id=\"the-y-bar-line.\" class=\"section level3\">\n<h3>The y-bar Line.<\/h3>\n<p>Given a set of <span class=\"math inline\">\\(n\\)<\/span> points on a\nscatter plot:<\/p>\n<p><span class=\"math display\">\\[(x_1,y_1),(x_2,y_2),\\ldots,(x_n,y_n),\\]<\/span><\/p>\n<p>the <span class=\"math inline\">\\(\\bar{y}\\)<\/span>-line is defined to\nbe the horizontal line whose y-intercept is:<\/p>\n<p><span class=\"math display\">\\[\\bar{y} = \\frac{\\sum_{i = 0}^{n}\ny_i}{n},\\]<\/span><\/p>\n<p>the mean of the <span class=\"math inline\">\\(y\\)<\/span>-coordinates of\nthe points on the scatter plot. Of all horizontal lines, it’s the one\nthat “best fits” the scatter plot, in the sense that you would use it to\npredict the <span class=\"math inline\">\\(y\\)<\/span>-value of an\nobservation if you were not allowed to take its <span class=\"math inline\">\\(x\\)<\/span>-value into account.<\/p>\n<p>When you begin a game, the <span class=\"math inline\">\\(\\bar{y}\\)<\/span>-line is drawn for you.<\/p>\n<\/div>\n<div id=\"error-sum-of-squares\" class=\"section level3\">\n<h3>Error Sum of Squares<\/h3>\n<p>For any line <span class=\"math inline\">\\(l\\)<\/span> with equation\n<span class=\"math inline\">\\(y = a + bx\\)<\/span>, we define the <em>error\nsum of squares<\/em> (ESS for short) of the line as follows:<\/p>\n<p><span class=\"math display\">\\[ESS_{l} = \\sum_{i = 0}^{n} (y_i - (a + b\nx_i))^2.\\]<\/span><\/p>\n<p>When you play the app, the ESS for the line you have at any given\nmoment is the sum of the squares of the vertical lines (drawn on the\nplot) between the given data points and your line.<\/p>\n<p>The regression line has the interesting property of being the line\nthat makes the ESS as small as possible. If your line has an ESS equal\nto that of the regression line, then it <em>is<\/em> the regression\nline!<\/p>\n<p>When you play the game, your “closeness measure” is determined by the\nfollowing formula:<\/p>\n<p><span class=\"math display\">\\[\\text{closeness} = \\frac{ESS_{\\text{your\ncurrent line}} - ESS_{\\text{the regression\nline}}}{ESS_{\\bar{y}\\text{-line}} - ESS_{\\text{the regression line}}}\n\\times 100.\\]<\/span><\/p>\n<p>Thus, the closeness measure computes how close your current line\ncomes to the regression line with how close the <span class=\"math inline\">\\(\\bar{y}\\)<\/span>-line is to the regression line.\nThis comparison is multiplied by 100 so that you can think of it as a\npercentage. When the game begins your line <em>is<\/em> the <span class=\"math inline\">\\(\\bar{y}\\)<\/span>-line, so the closeness measure is\n100%.<\/p>\n<p>Your score at any moment is:<\/p>\n<p><span class=\"math display\">\\[\\text{Score} = \\text{number of turns so\nfar} + \\text{current closeness measure}.\\]<\/span><\/p>\n<\/div>\n<\/div>\n<div id=\"suggestions\" class=\"section level2\">\n<h2>Suggestions<\/h2>\n<p>It’s often a good idea to work first with the slider that determines\nthe slope. Once you think you have the slope about right, use the\nintercept-slider to move the line up or down horizontally. You won’t get\na new score report until you submit, but you can move the line around as\nmuch as you like before committing yourself to a submission.<\/p>\n<p>Can you think of a situation where it is in your best interests to\nstop? (<strong>Hint: <\/strong> Each additional submission costs you an\nextra point.)<\/p>\n<\/div>\n<\/div>\n","type":"text"},{"name":"www/styles.css","content":"#aboutfile {\ncounter-reset:table figure;\n}\n\ncaption::before{\ncounter-increment: table;\ncontent: \"Table \" counter(table) \": \";\n}\n\n.caption::before{\ncounter-increment: figure;\ncontent: \"Figure \" counter(figure) \": \";\n}\n\n#aboutfile {\n  background-color: #fff;\n  margin: 1em auto;\n  overflow: visible;\n  max-width:  700px;\n  /* width: 80%;\n  padding-left: 10%;\n  padding-right:  10%; */\n  /* padding-left: 2em;\n  padding-right: 2em;*/\n  font-family: \"Open Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.35;\n}\n\n #header {\n  text-align: center;\n}\n\n #TOC {\n  clear: both;\n  margin: 0 0 10px 10px;\n  padding: 4px;\n  width: 400px;\n  border: 1px solid #CCCCCC;\n  border-radius: 5px;\n\n  background-color: #f6f6f6;\n  font-size: 13px;\n  line-height: 1.3;\n}\n  #TOC .toctitle {\n    font-weight: bold;\n    font-size: 15px;\n    margin-left: 5px;\n  }\n\n  #TOC ul {\n    padding-left: 40px;\n    margin-left: -1.5em;\n    margin-top: 5px;\n    margin-bottom: 5px;\n  }\n  #TOC ul ul {\n    margin-left: -2em;\n  }\n  #TOC li {\n    line-height: 16px;\n  }\n\n #aboutfile table {\n  margin: 1em auto;\n  border-width: 1px;\n  border-color: #DDDDDD;\n  border-style: outset;\n  border-collapse: collapse;\n}\n#aboutfile table th {\n  border-width: 2px;\n  padding: 5px;\n  border-style: inset;\n}\n#aboutfile table td {\n  border-width: 1px;\n  border-style: inset;\n  line-height: 18px;\n  padding: 5px 5px;\n}\n#aboutfile table, table th, table td {\n  border-left-style: none;\n  border-right-style: none;\n}\n#aboutfile table thead, table tr.even {\n  background-color: #f7f7f7;\n}\n\n#aboutfile p {\n  margin: 0.5em 0;\n}\n\n#aboutfile blockquote {\n  background-color: #f6f6f6;\n  padding: 0.25em 0.75em;\n}\n\n#aboutfile hr {\n  border-style: solid;\n  border: none;\n  border-top: 1px solid #777;\n  margin: 28px 0;\n}\n\n#aboutfile dl {\n  margin-left: 0;\n}\n#aboutfile   dl dd {\n    margin-bottom: 13px;\n    margin-left: 13px;\n  }\n#aboutfile   dl dt {\n    font-weight: bold;\n  }\n\n#aboutfile ul {\n  margin-top: 0;\n}\n#aboutfile ul li {\n    list-style: circle outside;\n  }\n#aboutfile ul ul {\n    margin-bottom: 0;\n  }\n\n#aboutfile pre, code {\n  background-color: #f7f7f7;\n  border-radius: 3px;\n  color: #333;\n}\n#aboutfile pre {\n  white-space: pre-wrap;    /* Wrap long lines */\n  border-radius: 3px;\n  margin: 5px 0px 10px 0px;\n  padding: 10px;\n}\n#aboutfile pre:not([class]) {\n  background-color: #f7f7f7;\n}\n\n#aboutfile code {\n  font-family: Consolas, Monaco, 'Courier New', monospace;\n  font-size: 85%;\n}\n#aboutfile p > code, li > code {\n  padding: 2px 0px;\n}\n\n#aboutfile div.figure {\n  text-align: center;\n}\n#aboutfile img {\n  background-color: #FFFFFF;\n  padding: 2px;\n  border: 1px solid #DDDDDD;\n  border-radius: 3px;\n  border: 1px solid #CCCCCC;\n  margin: 0 5px;\n}\n\n#aboutfile h1 {\n  margin-top: 0;\n  font-size: 35px;\n  line-height: 40px;\n}\n\n#aboutfile h2 {\n  border-bottom: 4px solid #f7f7f7;\n  padding-top: 10px;\n  padding-bottom: 2px;\n  font-size: 145%;\n}\n\n#aboutfile h3 {\n  border-bottom: 2px solid #f7f7f7;\n  padding-top: 10px;\n  font-size: 120%;\n}\n\n#aboutfile h4 {\n  border-bottom: 1px solid #f7f7f7;\n  margin-left: 8px;\n  font-size: 105%;\n}\n\n#aboutfile h5, h6 {\n  border-bottom: 1px solid #ccc;\n  font-size: 105%;\n}\n\n a {\n  color: #0033dd;\n  text-decoration: none;\n}\n#aboutfile  a:hover {\n    color: #6666ff; }\n#aboutfile  a:visited {\n    color: #800080; }\n#aboutfile  a:visited:hover {\n    color: #BB00BB; }\na[href^=\"http:\"] {\n    text-decoration: underline; }\na[href^=\"https:\"] {\n    text-decoration: underline; }\n\n/* Class described in https://benjeffrey.com/posts/pandoc-syntax-highlighting-css\n   Colours from https://gist.github.com/robsimmons/1172277 */\n\n code > span.kw { color: #555; font-weight: bold; } /* Keyword */\n code > span.dt { color: #902000; } /* DataType */\n code > span.dv { color: #40a070; } /* DecVal (decimal values) */\n code > span.bn { color: #d14; } /* BaseN */\n code > span.fl { color: #d14; } /* Float */\n code > span.ch { color: #d14; } /* Char */\n code > span.st { color: #d14; } /* String */\n code > span.co { color: #888888; font-style: italic; } /* Comment */\n code > span.ot { color: #007020; } /* OtherToken */\n code > span.al { color: #ff0000; font-weight: bold; } /* AlertToken */\n code > span.fu { color: #900; font-weight: bold; } /* Function calls */ \n code > span.er { color: #a61717; background-color: #e3d2d2; } /* ErrorTok */","type":"text"}]
